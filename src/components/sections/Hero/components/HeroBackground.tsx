// // src/components/sections/Hero/components/HeroBackground.tsx - VERSION OPTIMIS√âE
// import { Canvas, useFrame, type RootState } from '@react-three/fiber';
// import { Points } from '@react-three/drei';
// import { useRef, useEffect, useState, memo } from 'react';
// import { easing } from 'maath';
// import type { Points as ThreePoints, BufferGeometry, Material } from 'three';

// const AnimatedBackground = memo(() => {
//   const pointsRef = useRef<ThreePoints<BufferGeometry, Material>>(null);
//   const [isMobile, setIsMobile] = useState(false);
//   const [isReducedMotion, setIsReducedMotion] = useState(false);
//   const lastUpdateTimeRef = useRef(0);
  
//   // D√©tection optimis√©e
//   useEffect(() => {
//     const checkSettings = () => {
//       setIsMobile(window.innerWidth < 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
//       setIsReducedMotion(window.matchMedia('(prefers-reduced-motion: reduce)').matches);
//     };
    
//     checkSettings();
    
//     const resizeObserver = new ResizeObserver(checkSettings);
//     resizeObserver.observe(document.body);
    
//     const motionMedia = window.matchMedia('(prefers-reduced-motion: reduce)');
//     motionMedia.addEventListener('change', checkSettings);
    
//     return () => {
//       resizeObserver.disconnect();
//       motionMedia.removeEventListener('change', checkSettings);
//     };
//   }, []);
  
//   // ‚ö° OPTIMISATION PRO : Nombre raisonnable mais visible
//   const count = isReducedMotion ? 0 : (isMobile ? 30 : 60); // √âquilibre performance/beaut√©
  
//   // ‚ö° OPTIMISATION : Animation ultra-simplifi√©e avec throttling extr√™me
//   useFrame((state: RootState, delta: number) => {
//     if (!pointsRef.current || isReducedMotion || count === 0) return;
    
//     // üî• THROTTLING EXTR√äME : Mise √† jour toutes les 200ms sur mobile
//     const now = state.clock.getElapsedTime();
//     const throttleDelay = isMobile ? 0.2 : 0.1;
    
//     if (now - lastUpdateTimeRef.current < throttleDelay) return;
//     lastUpdateTimeRef.current = now;
    
//     const position = pointsRef.current.position;
//     // ‚ö° Animation plus lente et moins aggressive
//     easing.damp3(
//       position,
//       [
//         Math.sin(state.clock.elapsedTime * 0.02) * 1, // üî• Plus lent et amplitude r√©duite
//         Math.cos(state.clock.elapsedTime * 0.02) * 1,
//         0
//       ],
//       isMobile ? 0.5 : 0.3, // üî• Plus lent
//       delta
//     );
//   });

//   // üî• Ne pas rendre si pas de points
//   if (count === 0) return null;

//   return (
//     <Points
//       ref={pointsRef}
//       limit={count}
//       position={[0, 0, 0]}
//     >
//       <bufferGeometry>
//         <bufferAttribute
//           attach="attributes-position"
//           count={count}
//           array={new Float32Array(count * 3).map(() => (Math.random() - 0.5) * 6)} // ‚ö° Zone plus petite
//           itemSize={3}
//         />
//       </bufferGeometry>
//       <pointsMaterial
//         size={isMobile ? 0.02 : 0.03} // üî• Taille r√©duite
//         color="#4ADE80"
//         sizeAttenuation={false} // ‚ö° D√©sactiver pour performances
//         transparent
//         opacity={0.4} // üî• Moins visible
//         depthWrite={false} // ‚ö° Optimisation
//       />
//     </Points>
//   );
// });

// export const HeroBackground = memo(() => {
//   const [isVisible, setIsVisible] = useState(false);
//   const containerRef = useRef<HTMLDivElement>(null);
//   const [isMobile, setIsMobile] = useState(false);
//   const [isReducedMotion, setIsReducedMotion] = useState(false);
  
//   // D√©tection du type d'appareil et des pr√©f√©rences
//   useEffect(() => {
//     const checkSettings = () => {
//       setIsMobile(window.innerWidth < 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
//       setIsReducedMotion(window.matchMedia('(prefers-reduced-motion: reduce)').matches);
//     };
    
//     checkSettings();
//     window.addEventListener('resize', checkSettings);
    
//     const motionMedia = window.matchMedia('(prefers-reduced-motion: reduce)');
//     motionMedia.addEventListener('change', checkSettings);
    
//     return () => {
//       window.removeEventListener('resize', checkSettings);
//       motionMedia.removeEventListener('change', checkSettings);
//     };
//   }, []);
  
//   // Observer l'intersection avec seuil plus √©lev√©
//   useEffect(() => {
//     if (!containerRef.current) return;
    
//     const observer = new IntersectionObserver(
//       entries => {
//         entries.forEach(entry => {
//           setIsVisible(entry.isIntersecting);
//         });
//       },
//       {
//         threshold: 0.2, // ‚ö° Seuil plus √©lev√©
//         rootMargin: '100px' // ‚ö° Marge plus grande
//       }
//     );
    
//     observer.observe(containerRef.current);
    
//     return () => {
//       if (containerRef.current) {
//         observer.unobserve(containerRef.current);
//       }
//     };
//   }, []);

//   // üî• Fallback statique si animations r√©duites
//   if (isReducedMotion) {
//     return (
//       <div ref={containerRef} className="absolute inset-0">
//         <div className="absolute inset-0 bg-gradient-to-br from-[#4ADE80]/10 via-transparent to-[#4ADE80]/5" />
//       </div>
//     );
//   }

//   return (
//     <div ref={containerRef} className="absolute inset-0">
//       {isVisible && (
//         <Canvas
//           // ‚ö° OPTIMISATION MAJEURE : Configuration ultra-light
//           dpr={1} // üî• Pixel ratio fix√© √† 1
//           gl={{
//             antialias: false, // ‚ùå D√©sactiv√©
//             alpha: true,
//             powerPreference: 'high-performance',
//             precision: 'lowp', // ‚ö° Pr√©cision minimale
//             depth: false, // ‚ùå Pas de test de profondeur
//             stencil: false, // ‚ùå Pas de stencil buffer
//             preserveDrawingBuffer: false, // ‚ùå Pas de pr√©servation
//           }}
//           camera={{ fov: 75, position: [0, 0, 5] }}
//           style={{ pointerEvents: 'none' }}
//           frameloop="always" // ‚ö° Animation fluide mais contr√¥l√©e
//         >
//           <color attach="background" args={['#000000']} />
//           <AnimatedBackground />
          
//           // ‚ùå R√âACTIV√â : EffectComposer mais optimis√© pour mobile
//           {!isMobile && (
//             <>
//               {/* ‚ö° Bloom l√©ger seulement sur desktop */}
//               <fog attach="fog" args={['#000000', 1, 15]} />
//             </>
//           )}
//         </Canvas>
//       )}
//     </div>
//   );
// });

// export default HeroBackground;








// src/components/sections/Hero/components/HeroBackground.tsx - VERSION ULTRA-OPTIMIS√âE
import { Canvas, useFrame, type RootState } from '@react-three/fiber';
import { Points } from '@react-three/drei';
import { useRef, useEffect, useState, memo } from 'react';
import { easing } from 'maath';
import type { Points as ThreePoints, BufferGeometry, Material } from 'three';

const AnimatedBackground = memo(() => {
  const pointsRef = useRef<ThreePoints<BufferGeometry, Material>>(null);
  const [isMobile, setIsMobile] = useState(false);
  const [isReducedMotion, setIsReducedMotion] = useState(false);
  const lastUpdateTimeRef = useRef(0);
  
  // D√©tection optimis√©e
  useEffect(() => {
    const checkSettings = () => {
      setIsMobile(window.innerWidth < 768);
      setIsReducedMotion(window.matchMedia('(prefers-reduced-motion: reduce)').matches);
    };
    
    checkSettings();
    
    const resizeObserver = new ResizeObserver(checkSettings);
    resizeObserver.observe(document.body);
    
    const motionMedia = window.matchMedia('(prefers-reduced-motion: reduce)');
    motionMedia.addEventListener('change', checkSettings);
    
    return () => {
      resizeObserver.disconnect();
      motionMedia.removeEventListener('change', checkSettings);
    };
  }, []);
  
  // ‚ö° OPTIMISATION PRO : Nombre ultra-r√©duit mais visible
  const count = isReducedMotion ? 0 : (isMobile ? 20 : 40); // üî• Drastiquement r√©duit
  
  // ‚ö° OPTIMISATION : Animation ultra-simplifi√©e avec throttling extr√™me
  useFrame((state: RootState, delta: number) => {
    if (!pointsRef.current || isReducedMotion || count === 0) return;
    
    // üî• THROTTLING EXTR√äME : Mise √† jour toutes les 300ms sur mobile, 150ms desktop
    const now = state.clock.getElapsedTime();
    const throttleDelay = isMobile ? 0.3 : 0.15;
    
    if (now - lastUpdateTimeRef.current < throttleDelay) return;
    lastUpdateTimeRef.current = now;
    
    const position = pointsRef.current.position;
    // ‚ö° Animation ultra-lente et minimaliste
    easing.damp3(
      position,
      [
        Math.sin(state.clock.elapsedTime * 0.01) * 0.5, // üî• Tr√®s lent et amplitude minimale
        Math.cos(state.clock.elapsedTime * 0.01) * 0.5,
        0
      ],
      isMobile ? 0.8 : 0.6, // üî• Tr√®s lent
      delta
    );
  });

  // üî• Ne pas rendre si pas de points
  if (count === 0) return null;

  return (
    <Points
      ref={pointsRef}
      limit={count}
      position={[0, 0, 0]}
    >
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          count={count}
          array={new Float32Array(count * 3).map(() => (Math.random() - 0.5) * 4)} // ‚ö° Zone encore plus petite
          itemSize={3}
        />
      </bufferGeometry>
      <pointsMaterial
        size={isMobile ? 0.015 : 0.02} // üî• Encore plus petit
        color="#4ADE80"
        sizeAttenuation={false} // ‚ö° D√©sactiver pour performances
        transparent
        opacity={0.3} // üî• Tr√®s discret
        depthWrite={false} // ‚ö° Optimisation
      />
    </Points>
  );
});

export const HeroBackground = memo(() => {
  const [isVisible, setIsVisible] = useState(false);
  const [showCanvas, setShowCanvas] = useState(false); // üî• Nouveau state
  const containerRef = useRef<HTMLDivElement>(null);
  const [isMobile, setIsMobile] = useState(false);
  const [isReducedMotion, setIsReducedMotion] = useState(false);
  
  // D√©tection du type d'appareil et des pr√©f√©rences
  useEffect(() => {
    const checkSettings = () => {
      setIsMobile(window.innerWidth < 768);
      setIsReducedMotion(window.matchMedia('(prefers-reduced-motion: reduce)').matches);
    };
    
    checkSettings();
    window.addEventListener('resize', checkSettings);
    
    const motionMedia = window.matchMedia('(prefers-reduced-motion: reduce)');
    motionMedia.addEventListener('change', checkSettings);
    
    return () => {
      window.removeEventListener('resize', checkSettings);
      motionMedia.removeEventListener('change', checkSettings);
    };
  }, []);
  
  // Observer l'intersection avec seuil plus √©lev√©
  useEffect(() => {
    if (!containerRef.current) return;
    
    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          setIsVisible(entry.isIntersecting);
        });
      },
      {
        threshold: 0.1, // ‚ö° Seuil r√©duit
        rootMargin: '200px' // ‚ö° Marge tr√®s grande
      }
    );
    
    observer.observe(containerRef.current);
    
    return () => {
      if (containerRef.current) {
        observer.unobserve(containerRef.current);
      }
    };
  }, []);

  // üî• CHARGEMENT DIFF√âR√â DU CANVAS APR√àS 2 SECONDES
  useEffect(() => {
    if (isVisible && !isReducedMotion) {
      const timer = setTimeout(() => {
        setShowCanvas(true);
      }, 2000); // ‚ö° Attendre 2 secondes apr√®s visibilit√©
      
      return () => clearTimeout(timer);
    }
  }, [isVisible, isReducedMotion]);

  // üî• Fallback statique imm√©diat
  if (isReducedMotion) {
    return (
      <div ref={containerRef} className="absolute inset-0">
        <div className="absolute inset-0 bg-gradient-to-br from-[#4ADE80]/8 via-transparent to-[#4ADE80]/4" />
      </div>
    );
  }

  return (
    <div ref={containerRef} className="absolute inset-0">
      {/* üî• FALLBACK IMM√âDIAT PENDANT CHARGEMENT */}
      {!showCanvas && (
        <div className="absolute inset-0 bg-gradient-to-br from-[#4ADE80]/6 via-transparent to-[#4ADE80]/3" />
      )}
      
      {/* üî• CANVAS CHARG√â APR√àS D√âLAI */}
      {isVisible && showCanvas && (
        <Canvas
          // ‚ö° OPTIMISATION MAXIMALE : Configuration ultra-light
          dpr={isMobile ? 0.5 : 1} // üî• Pixel ratio ultra-r√©duit sur mobile
          gl={{
            antialias: false, // ‚ùå D√©sactiv√©
            alpha: true,
            powerPreference: 'high-performance',
            precision: 'lowp', // ‚ö° Pr√©cision minimale
            depth: false, // ‚ùå Pas de test de profondeur
            stencil: false, // ‚ùå Pas de stencil buffer
            preserveDrawingBuffer: false, // ‚ùå Pas de pr√©servation
            failIfMajorPerformanceCaveat: true, // üî• Fail si mauvaises perfs
          }}
          camera={{ fov: 75, position: [0, 0, 5] }}
          style={{ pointerEvents: 'none' }}
          frameloop="demand" // ‚ö° Rendu √† la demande uniquement
        >
          <color attach="background" args={['#000000']} />
          <AnimatedBackground />
        </Canvas>
      )}
    </div>
  );
});

export default HeroBackground;